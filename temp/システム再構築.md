以下、各再構築手法の概要を表形式でまとめます：

| 再構築手法 | 概要 | 要件定義 | 基本設計/<br>詳細設計 | プログラム設計 | プログラムソース | 主な特徴 |
|---------|------|---------|---------|------------|-------------|---------|
| **HW更改** | ハードウェアの更改を行う際にOSやミドルウェア製品のバージョンが変わる場合。プログラムの修正が発生する場合もある | 現行踏襲 | 現行踏襲<br>（OS、ミドルウェア製品のバージョン変更に伴う修正の場合あり） | 現行踏襲<br>（OS、ミドルウェア製品のバージョン変更に伴う修正の場合あり） | 現行踏襲<br>（OS、ミドルウェア製品のバージョン変更に伴う修正の場合あり） | ハードウェアを同一機種、または後継機への乗り換りに伴い、OS、ミドルウェア製品のバージョンが上がることはあるが、製品の種類は変更しない |
| **リホスト** | プログラムは現行と同一の言語で、原則そのまま新規プラットフォームへ移行する | 現行踏襲 | 現行踏襲<br>プラットフォーム変更に伴う修正あり | 現行踏襲<br>プラットフォーム変更に伴う修正あり | 現行踏襲<br>プラットフォーム変更に伴う修正あり | 「現行と同一の言語」について、例えばメインフレームCOBOLからオープン系COBOLに変わるケースはどちらも含む |
| **リライト** | 現行のプログラム設計書をもとに、異なる言語で新規プラットフォームに変更する | 現行踏襲 | 現行踏襲<br>プラットフォーム変更に伴う修正及び言語依存・新規機能分割設計書 | 再生成 | 再生成 | プラットフォーム変更に伴う修正あり |
| **リビルド** | 現行の要件定義書をもとに新規システム構築。業務要件は変えずに、アプリケーションを全面的に変える | 現行踏襲 | 再設計 | 再設計 | 再生成 | - |
| **パッケージ<br>製品の利用** | パッケージ製品を組み込む。開発コストダウンや自社保有アプリケーション資産削減、業界標準適用が目的 | Fit&Gap分析に基づく | タイプにより異なる：<br>①パラメタ設定のみ<br>②カスタマイズ開発<br>③アドオン開発 | （同左） | （同左） | **メリット**: 高品質・短期導入・低コスト<br>**注意点**: 現行業務運用との適合性確認が重要。Fit&Gap分析不足によるカスタマイズ・アドオン規模の増大リスク |
---

| 再構築手法 | Pros（メリット） | Cons（デメリット） | 実現難易度 | 品質管理とリスク管理 |
|---------|----------------|------------------|-----------|-------------------|
| **HW更改** | • 短期間で実施可能<br>• コストが最小<br>• 業務有識者の関与度が小<br>• 現行システムと同じ動作を維持しやすい | • 新プラットフォームの活用は限定的<br>• アプリケーション保守性は現行と同等（向上なし）<br>• 業務柔軟性の向上なし<br>• 運用コスト削減効果は限定的 | **小** | **検証方法**: 標準レベル<br>**主なリスク**:<br>• バージョン変更に伴う互換性問題<br>• 想定外の修正の発生 |
| **リホスト** | • 比較的短期間で実施可能<br>• コストは小～中程度<br>• 業務仕様の再現性が高い<br>• 現行資産（設計書）を活用可能<br>• 新プラットフォームへの移行が可能 | • アプリケーション保守性は現行と同等<br>• 業務柔軟性の向上なし<br>• プラットフォームや言語環境変更による不具合リスク<br>• カスタマイズ（現行踏襲外のテスト）が必要 | **小～中** | **検証方法**: プラットフォームや言語環境変更による不具合検証<br>**主なリスク**:<br>• 現行踏襲部分の仕様把握不足<br>• 移行時の互換性問題<br>• テスト・運用環境での差異<br>• コンバージョンツールの品質 |
| **リライト** | • プログラム言語の変更により保守性向上の可能性<br>• 最新技術への対応<br>• 業務仕様の再現性は保持可能<br>• 新プラットフォームの活用 | • コストは中程度<br>• 業務有識者の関与は必要<br>• 業務柔軟性は現行と同程度<br>• プログラム設計の再生成が必要<br>• 言語変更に伴うリスク | **中** | **検証方法**: プラットフォーム変更に伴う修正及び言語依存・新規機能分割設計書のホワイトボックステスト<br>**主なリスク**:<br>• 左記に加えて、言語変更に伴う品合否の見極め困難<br>• 現行設計書と実装の乖離<br>• 資産管理の複雑化 |
| **リビルド** | • アプリケーション保守性の大幅向上<br>• 業務柔軟性の向上（現行→再設計で改善）<br>• 新プラットフォームの全面活用<br>• 将来の保守コスト削減可能<br>• 新規業務への対応力向上 | • **コストが大**（最も高い）<br>• **期間が長期**<br>• **業務有識者の関与度が大**（最も高い）<br>• 設計からの全面的な作り直しが必要<br>• プロジェクトリスクが高い | **大** | **検証方法**: 再設計後の設計書に基づいたホワイトボックステスト<br>**主なリスク**:<br>• 業務知識不足による要件定義の誤り<br>• 作り込み品質の確保<br>• 業務仕様の見極め困難<br>• テスト、運用環境での手戻り<br>• 全面的な再設計によるリスク増大 |
| **パッケージ製品の利用** | • **高品質**（製品として実績あり）<br>• **短期導入**<br>• **低コスト**（標準機能利用時）<br>• 業界標準の適用<br>• 自社保有アプリ資産削減<br>• 運用コスト削減の可能性 | • **Fit&Gap分析不足による拡張規模増大リスク**<br>• 現行業務運用との適合性確保が困難<br>• カスタマイズ・アドオン増加でメリット喪失<br>• 業務運用変更への抵抗<br>• パッケージ製品への依存 | **中～大**<br>（Fit&Gap分析と業務変更の受容度に依存） | **検証方法**: Fit&Gap分析、パイロット検証、プロトタイプ確認<br>**主なリスク**:<br>• Fit&Gap分析不足→カスタマイズ・アドオン規模増大<br>• 非機能要件（性能等）の見落とし<br>• 業務部門からの「現行通り」要望による拡張増加<br>• 外部システムとのI/F変更対応<br>• パッケージベンダ依存によるリスク<br>**重要**: 企画段階での十分なFit&Gap分析とユーザ部門との合意形成が必須 |
---

一般的なIT構築プロジェクトにおける「新規スクラッチ開発」と「本番システムの拡張利用」について、同様の観点で表を作成します。

## 表1: 概要

| 手法 | 概要 | 要件定義 | 基本設計/<br>詳細設計 | プログラム設計 | プログラムソース | 主な特徴 |
|------|------|---------|---------|------------|-------------|---------|
| **新規スクラッチ開発** | 既存システムに依存せず、ゼロから新しいシステムを構築。新規事業、新規業務、または既存システムとの互換性を考慮しない全面刷新が対象 | 新規作成 | 新規作成 | 新規作成 | 新規作成 | **既存資産の制約なし**: 最新技術・アーキテクチャを自由に選択可能。レガシーな技術的負債を引き継がない。ビジネス要件に最適化した設計が可能 |
| **本番システムの拡張利用** | 稼働中の既存システムに対して、機能追加・改修を実施。システムの基盤は維持したまま、アプリケーション層を段階的に拡張 | 既存システムを前提に追加要件を定義 | 既存設計を踏襲し、追加・変更部分のみ設計 | 既存設計を踏襲し、追加・変更部分のみ設計 | 既存ソースに追加・修正 | **段階的な拡張**: システム停止を最小限に抑えながら機能追加。既存システムとの整合性維持が必須。比較的小規模な変更に適している |

## 表2: Pros/Cons、実現難易度、品質管理とリスク管理

| 手法 | Pros（メリット） | Cons（デメリット） | 実現難易度 | 品質管理とリスク管理 |
|------|----------------|------------------|-----------|-------------------|
| **新規スクラッチ開発** | • **技術選択の自由度が最大**<br>• 最新技術・アーキテクチャの採用可能<br>• レガシーな技術的負債がない<br>• ビジネス要件に最適化した設計<br>• 将来の拡張性を見据えた設計が可能<br>• 既存システムの制約・しがらみなし<br>• 保守性・柔軟性を最大化できる<br>• クラウドネイティブ等の最新パラダイム採用可 | • **コストが最大**<br>• **開発期間が最長**<br>• **プロジェクトリスクが最高**<br>• 要件定義の難易度が高い<br>• 業務知識のゼロからの構築<br>• 稼働実績がないため品質予測困難<br>• 全てを自前で構築する負担<br>• 初期バグの多発リスク<br>• ユーザー教育コストが大<br>• ROI実現まで時間がかかる | **大～最大** | **検証方法**: 全工程での品質作り込み（V字モデル）、段階的なプロトタイピング、PoC実施<br>**主なリスク**:<br>• **要件定義の不備・漏れ**: ゼロから定義するため見落としリスク大<br>• **技術選定の失敗**: 未経験技術採用による習熟不足<br>• **スコープクリープ**: 要件の膨張による工期・コスト超過<br>• **品質の不確実性**: 実績がないため予測困難<br>• **統合テストの複雑化**: 全機能の組み合わせテスト<br>• **ユーザー受容性**: 新システムへの抵抗<br>• **性能・スケーラビリティ未検証**<br>• **チーム習熟度**: 新技術への学習曲線<br>**対策**: 段階的リリース（MVP）、アジャイル開発、継続的な品質検証 |
| **本番システムの拡張利用** | • **コストが最小**<br>• **開発期間が最短**<br>• 既存システムの安定性活用<br>• 既存ユーザーへの影響最小<br>• 段階的な機能追加が可能<br>• 既存インフラ・ライセンス活用<br>• 既存の運用体制・ノウハウ活用<br>• ビジネス継続性の維持<br>• 投資対効果が明確（追加機能分のみ）<br>• リスクの局所化 | • **技術的負債の蓄積**<br>• **既存システムの制約に縛られる**<br>• アーキテクチャの改善困難<br>• 拡張の限界（スケーラビリティ）<br>• 既存コードの複雑化・肥大化<br>• レガシー技術への依存継続<br>• 段階的な変更による一貫性欠如リスク<br>• ドキュメントの陳腐化<br>• 保守性の低下<br>• 将来的な全面刷新の必要性 | **小～中**<br>（変更規模と既存システムの複雑さに依存） | **検証方法**: 影響範囲分析、既存機能のリグレッションテスト、段階的リリースとロールバック計画<br>**主なリスク**:<br>• **既存機能への影響（リグレッション）**: 想定外の箇所への波及<br>• **既存システムの理解不足**: ドキュメント不足、有識者不在<br>• **技術的負債の増加**: 継ぎはぎによる複雑化<br>• **性能劣化**: 既存処理への負荷増<br>• **データ整合性**: 既存データとの整合性維持<br>• **アーキテクチャの歪み**: 本来の設計思想との乖離<br>• **テスト範囲の見極め困難**: どこまでテストすべきか判断難<br>• **本番環境での予期せぬ問題**: 開発環境との差異<br>• **バージョン管理の複雑化**<br>**対策**: 徹底した影響範囲分析、自動テストの整備、段階的ロールアウト、ロールバック計画、カナリアリリース |

### 補足：選択基準と使い分け

| 観点 | 新規スクラッチ開発を選ぶべき場合 | 本番システムの拡張利用を選ぶべき場合 |
|------|-------------------------|---------------------------|
| **ビジネス状況** | • 新規事業・サービス立ち上げ<br>• 既存システムとの連携不要<br>• ビジネスモデルの抜本的変革<br>• 既存システムが技術的に限界 | • 既存ビジネスの延長線上<br>• 小規模な機能追加・改善<br>• 段階的な進化が望ましい<br>• ビジネス継続性が最優先 |
| **技術的要因** | • レガシー技術からの脱却<br>• 最新技術スタックの採用<br>• スケーラビリティ要件の変化<br>• 既存システムの保守限界 | • 既存技術スタックで実現可能<br>• 既存アーキテクチャで対応可<br>• 既存インフラで十分<br>• 技術的リスクを避けたい |
| **予算・期間** | • 大規模予算が確保可能<br>• 長期的視点での投資<br>• ROI実現まで時間的余裕あり | • 予算制約が厳しい<br>• 短期間でのリリース必須<br>• 即座のROI実現が求められる |
| **リスク許容度** | • 高いリスクを許容可能<br>• 失敗しても事業への影響は限定的<br>• PoC・MVPで段階的検証可 | • リスク最小化が最優先<br>• 既存事業への影響回避<br>• 安定稼働の継続が必須 |
| **組織的要因** | • 新規チーム編成が可能<br>• 新技術習得の時間確保可<br>• 既存システムからの独立性 | • 既存チームの活用<br>• 現状の運用体制維持<br>• 既存知識・ノウハウの活用 |

### 再構築手法との比較における位置づけ

**コスト・期間・リスクの順序**（低 → 高）:
1. 本番システムの拡張利用
2. HW更改
3. リホスト
4. リライト
5. パッケージ製品（標準機能のみ）
6. リビルド
7. パッケージ製品（大規模カスタマイズ）
8. 新規スクラッチ開発

**技術的自由度・将来性**（低 → 高）:
1. 本番システムの拡張利用
2. HW更改
3. リホスト
4. リライト
5. パッケージ製品
6. リビルド
7. 新規スクラッチ開発

**実務における選択パターン**:
- **保守的アプローチ**: 本番拡張 → HW更改 → リホスト → リライト → リビルド
- **革新的アプローチ**: 新規スクラッチ開発 または パッケージ導入
- **ハイブリッド**: 段階的に本番拡張しつつ、並行して新規開発を進める（ストラングラーパターン）
